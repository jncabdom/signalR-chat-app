{"ast":null,"code":"import _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// Not exported from index\n/** @private */\nexport var TextMessageFormat = /*#__PURE__*/function () {\n  function TextMessageFormat() {\n    _classCallCheck(this, TextMessageFormat);\n  }\n  _createClass(TextMessageFormat, null, [{\n    key: \"write\",\n    value: function write(output) {\n      return \"\".concat(output).concat(TextMessageFormat.RecordSeparator);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(input) {\n      if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\n        throw new Error(\"Message is incomplete.\");\n      }\n      var messages = input.split(TextMessageFormat.RecordSeparator);\n      messages.pop();\n      return messages;\n    }\n  }]);\n  return TextMessageFormat;\n}();\nTextMessageFormat.RecordSeparatorCode = 0x1e;\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);","map":{"version":3,"names":["TextMessageFormat","_classCallCheck","_createClass","key","value","write","output","concat","RecordSeparator","parse","input","length","Error","messages","split","pop","RecordSeparatorCode","String","fromCharCode"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/TextMessageFormat.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n"],"mappings":";;AAAA;AACA;AAEA;AACA;AACA,WAAaA,iBAAiB;EAAA,SAAAA,kBAAA;IAAAC,eAAA,OAAAD,iBAAA;EAAA;EAAAE,YAAA,CAAAF,iBAAA;IAAAG,GAAA;IAAAC,KAAA,EAInB,SAAAC,MAAaC,MAAc;MAC9B,UAAAC,MAAA,CAAUD,MAAM,EAAAC,MAAA,CAAGP,iBAAiB,CAACQ,eAAe;IACxD;EAAC;IAAAL,GAAA;IAAAC,KAAA,EAEM,SAAAK,MAAaC,KAAa;MAC7B,IAAIA,KAAK,CAACA,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,KAAKX,iBAAiB,CAACQ,eAAe,EAAE;QAC/D,MAAM,IAAII,KAAK,CAAC,wBAAwB,CAAC;;MAG7C,IAAMC,QAAQ,GAAGH,KAAK,CAACI,KAAK,CAACd,iBAAiB,CAACQ,eAAe,CAAC;MAC/DK,QAAQ,CAACE,GAAG,EAAE;MACd,OAAOF,QAAQ;IACnB;EAAC;EAAA,OAAAb,iBAAA;AAAA;AAfaA,iBAAA,CAAAgB,mBAAmB,GAAG,IAAI;AAC1BhB,iBAAA,CAAAQ,eAAe,GAAGS,MAAM,CAACC,YAAY,CAAClB,iBAAiB,CAACgB,mBAAmB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}