{"ast":null,"code":"import _regeneratorRuntime from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { HttpClient } from \"./HttpClient\";\n/** @private */\nexport var AccessTokenHttpClient = /*#__PURE__*/function (_HttpClient) {\n  _inherits(AccessTokenHttpClient, _HttpClient);\n  var _super = _createSuper(AccessTokenHttpClient);\n  function AccessTokenHttpClient(innerClient, accessTokenFactory) {\n    var _this;\n    _classCallCheck(this, AccessTokenHttpClient);\n    _this = _super.call(this);\n    _this._innerClient = innerClient;\n    _this._accessTokenFactory = accessTokenFactory;\n    return _this;\n  }\n  _createClass(AccessTokenHttpClient, [{\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {\n        var allowRetry, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              allowRetry = true;\n              if (!(this._accessTokenFactory && (!this._accessToken || request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\n                _context.next = 6;\n                break;\n              }\n              // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n              allowRetry = false;\n              _context.next = 5;\n              return this._accessTokenFactory();\n            case 5:\n              this._accessToken = _context.sent;\n            case 6:\n              this._setAuthorizationHeader(request);\n              _context.next = 9;\n              return this._innerClient.send(request);\n            case 9:\n              response = _context.sent;\n              if (!(allowRetry && response.statusCode === 401 && this._accessTokenFactory)) {\n                _context.next = 18;\n                break;\n              }\n              _context.next = 13;\n              return this._accessTokenFactory();\n            case 13:\n              this._accessToken = _context.sent;\n              this._setAuthorizationHeader(request);\n              _context.next = 17;\n              return this._innerClient.send(request);\n            case 17:\n              return _context.abrupt(\"return\", _context.sent);\n            case 18:\n              return _context.abrupt(\"return\", response);\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n  }, {\n    key: \"_setAuthorizationHeader\",\n    value: function _setAuthorizationHeader(request) {\n      if (!request.headers) {\n        request.headers = {};\n      }\n      if (this._accessToken) {\n        request.headers[HeaderNames.Authorization] = \"Bearer \".concat(this._accessToken);\n      }\n      // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n      else if (this._accessTokenFactory) {\n        if (request.headers[HeaderNames.Authorization]) {\n          delete request.headers[HeaderNames.Authorization];\n        }\n      }\n    }\n  }, {\n    key: \"getCookieString\",\n    value: function getCookieString(url) {\n      return this._innerClient.getCookieString(url);\n    }\n  }]);\n  return AccessTokenHttpClient;\n}(HttpClient);","map":{"version":3,"names":["HeaderNames","HttpClient","AccessTokenHttpClient","_HttpClient","_inherits","_super","_createSuper","innerClient","accessTokenFactory","_this","_classCallCheck","call","_innerClient","_accessTokenFactory","_createClass","key","value","_send","_asyncToGenerator","_regeneratorRuntime","mark","_callee","request","allowRetry","response","wrap","_callee$","_context","prev","next","_accessToken","url","indexOf","sent","_setAuthorizationHeader","send","statusCode","abrupt","stop","_x","apply","arguments","headers","Authorization","concat","getCookieString"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/AccessTokenHttpClient.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\n\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    private _innerClient: HttpClient;\r\n    _accessToken: string | undefined;\r\n    _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n\r\n    constructor(innerClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined) {\r\n        super();\r\n\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    private _setAuthorizationHeader(request: HttpRequest) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}