{"ast":null,"code":"import _regeneratorRuntime from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\nexport var ServerSentEventsTransport = /*#__PURE__*/function () {\n  function ServerSentEventsTransport(httpClient, accessToken, logger, options) {\n    _classCallCheck(this, ServerSentEventsTransport);\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  _createClass(ServerSentEventsTransport, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, transferFormat) {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              Arg.isRequired(url, \"url\");\n              Arg.isRequired(transferFormat, \"transferFormat\");\n              Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n              this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\n              // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n              this._url = url;\n              if (this._accessToken) {\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(this._accessToken));\n              }\n              return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var opened = false;\n                if (transferFormat !== TransferFormat.Text) {\n                  reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n                  return;\n                }\n                var eventSource;\n                if (Platform.isBrowser || Platform.isWebWorker) {\n                  eventSource = new _this._options.EventSource(url, {\n                    withCredentials: _this._options.withCredentials\n                  });\n                } else {\n                  // Non-browser passes cookies via the dictionary\n                  var cookies = _this._httpClient.getCookieString(url);\n                  var headers = {};\n                  headers.Cookie = cookies;\n                  var _getUserAgentHeader = getUserAgentHeader(),\n                    _getUserAgentHeader2 = _slicedToArray(_getUserAgentHeader, 2),\n                    name = _getUserAgentHeader2[0],\n                    value = _getUserAgentHeader2[1];\n                  headers[name] = value;\n                  eventSource = new _this._options.EventSource(url, {\n                    withCredentials: _this._options.withCredentials,\n                    headers: _objectSpread(_objectSpread({}, headers), _this._options.headers)\n                  });\n                }\n                try {\n                  eventSource.onmessage = function (e) {\n                    if (_this.onreceive) {\n                      try {\n                        _this._logger.log(LogLevel.Trace, \"(SSE transport) data received. \".concat(getDataDetail(e.data, _this._options.logMessageContent), \".\"));\n                        _this.onreceive(e.data);\n                      } catch (error) {\n                        _this._close(error);\n                        return;\n                      }\n                    }\n                  };\n                  // @ts-ignore: not using event on purpose\n                  eventSource.onerror = function (e) {\n                    // EventSource doesn't give any useful information about server side closes.\n                    if (opened) {\n                      _this._close();\n                    } else {\n                      reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n                    }\n                  };\n                  eventSource.onopen = function () {\n                    _this._logger.log(LogLevel.Information, \"SSE connected to \".concat(_this._url));\n                    _this._eventSource = eventSource;\n                    opened = true;\n                    resolve();\n                  };\n                } catch (e) {\n                  reject(e);\n                  return;\n                }\n              }));\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this._eventSource) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\", Promise.reject(new Error(\"Cannot send until the transport is connected\")));\n            case 2:\n              return _context2.abrupt(\"return\", sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options));\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._close();\n      return Promise.resolve();\n    }\n  }, {\n    key: \"_close\",\n    value: function _close(e) {\n      if (this._eventSource) {\n        this._eventSource.close();\n        this._eventSource = undefined;\n        if (this.onclose) {\n          this.onclose(e);\n        }\n      }\n    }\n  }]);\n  return ServerSentEventsTransport;\n}();","map":{"version":3,"names":["LogLevel","TransferFormat","Arg","getDataDetail","getUserAgentHeader","Platform","sendMessage","ServerSentEventsTransport","httpClient","accessToken","logger","options","_classCallCheck","_httpClient","_accessToken","_logger","_options","onreceive","onclose","_createClass","key","value","_connect","_asyncToGenerator","_regeneratorRuntime","mark","_callee","url","transferFormat","_this","wrap","_callee$","_context","prev","next","isRequired","isIn","log","Trace","_url","indexOf","concat","encodeURIComponent","abrupt","Promise","resolve","reject","opened","Text","Error","eventSource","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","_getUserAgentHeader","_getUserAgentHeader2","_slicedToArray","name","_objectSpread","onmessage","e","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","stop","connect","_x","_x2","apply","arguments","_send","_callee2","_callee2$","_context2","send","_x3","close","undefined"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/ServerSentEventsTransport.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessToken: string | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private _eventSource?: EventSource;\r\n    private _url?: string;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessToken: string | undefined, logger: ILogger,\r\n                options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent!)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e: Event) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    } else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(e?: Error) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}