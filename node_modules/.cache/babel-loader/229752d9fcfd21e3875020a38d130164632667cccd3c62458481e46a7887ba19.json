{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { NullLogger } from \"./Loggers\";\nimport { TextMessageFormat } from \"./TextMessageFormat\";\nvar JSON_HUB_PROTOCOL_NAME = \"json\";\n/** Implements the JSON Hub Protocol. */\nexport var JsonHubProtocol = /*#__PURE__*/function () {\n  function JsonHubProtocol() {\n    _classCallCheck(this, JsonHubProtocol);\n    /** @inheritDoc */\n    this.name = JSON_HUB_PROTOCOL_NAME;\n    /** @inheritDoc */\n    this.version = 1;\n    /** @inheritDoc */\n    this.transferFormat = TransferFormat.Text;\n  }\n  /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n   *\r\n   * @param {string} input A string containing the serialized representation.\r\n   * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n   */\n  _createClass(JsonHubProtocol, [{\n    key: \"parseMessages\",\n    value: function parseMessages(input, logger) {\n      // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\n      if (typeof input !== \"string\") {\n        throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n      }\n      if (!input) {\n        return [];\n      }\n      if (logger === null) {\n        logger = NullLogger.instance;\n      }\n      // Parse the messages\n      var messages = TextMessageFormat.parse(input);\n      var hubMessages = [];\n      var _iterator = _createForOfIteratorHelper(messages),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var message = _step.value;\n          var parsedMessage = JSON.parse(message);\n          if (typeof parsedMessage.type !== \"number\") {\n            throw new Error(\"Invalid payload.\");\n          }\n          switch (parsedMessage.type) {\n            case MessageType.Invocation:\n              this._isInvocationMessage(parsedMessage);\n              break;\n            case MessageType.StreamItem:\n              this._isStreamItemMessage(parsedMessage);\n              break;\n            case MessageType.Completion:\n              this._isCompletionMessage(parsedMessage);\n              break;\n            case MessageType.Ping:\n              // Single value, no need to validate\n              break;\n            case MessageType.Close:\n              // All optional values, no need to validate\n              break;\n            default:\n              // Future protocol changes can add message types, old clients can ignore them\n              logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\n              continue;\n          }\n          hubMessages.push(parsedMessage);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return hubMessages;\n    }\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\n  }, {\n    key: \"writeMessage\",\n    value: function writeMessage(message) {\n      return TextMessageFormat.write(JSON.stringify(message));\n    }\n  }, {\n    key: \"_isInvocationMessage\",\n    value: function _isInvocationMessage(message) {\n      this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\n      if (message.invocationId !== undefined) {\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\n      }\n    }\n  }, {\n    key: \"_isStreamItemMessage\",\n    value: function _isStreamItemMessage(message) {\n      this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\n      if (message.item === undefined) {\n        throw new Error(\"Invalid payload for StreamItem message.\");\n      }\n    }\n  }, {\n    key: \"_isCompletionMessage\",\n    value: function _isCompletionMessage(message) {\n      if (message.result && message.error) {\n        throw new Error(\"Invalid payload for Completion message.\");\n      }\n      if (!message.result && message.error) {\n        this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\n      }\n      this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\n    }\n  }, {\n    key: \"_assertNotEmptyString\",\n    value: function _assertNotEmptyString(value, errorMessage) {\n      if (typeof value !== \"string\" || value === \"\") {\n        throw new Error(errorMessage);\n      }\n    }\n  }]);\n  return JsonHubProtocol;\n}();","map":{"version":3,"names":["MessageType","LogLevel","TransferFormat","NullLogger","TextMessageFormat","JSON_HUB_PROTOCOL_NAME","JsonHubProtocol","_classCallCheck","name","version","transferFormat","Text","_createClass","key","value","parseMessages","input","logger","Error","instance","messages","parse","hubMessages","_iterator","_createForOfIteratorHelper","_step","s","n","done","message","parsedMessage","JSON","type","Invocation","_isInvocationMessage","StreamItem","_isStreamItemMessage","Completion","_isCompletionMessage","Ping","Close","log","Information","push","err","e","f","writeMessage","write","stringify","_assertNotEmptyString","target","invocationId","undefined","item","result","error","errorMessage"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/JsonHubProtocol.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { CompletionMessage, HubMessage, IHubProtocol, InvocationMessage, MessageType, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\n\r\nconst JSON_HUB_PROTOCOL_NAME: string = \"json\";\r\n\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol implements IHubProtocol {\r\n\r\n    /** @inheritDoc */\r\n    public readonly name: string = JSON_HUB_PROTOCOL_NAME;\r\n    /** @inheritDoc */\r\n    public readonly version: number = 1;\r\n\r\n    /** @inheritDoc */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Text;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: string, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n\r\n        if (!input) {\r\n            return [];\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message) as HubMessage;\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n\r\n    private _isInvocationMessage(message: InvocationMessage): void {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n\r\n    private _isStreamItemMessage(message: StreamItemMessage): void {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n\r\n    private _isCompletionMessage(message: CompletionMessage): void {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n\r\n    private _assertNotEmptyString(value: any, errorMessage: string): void {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}