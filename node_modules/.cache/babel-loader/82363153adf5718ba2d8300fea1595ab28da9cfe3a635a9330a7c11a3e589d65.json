{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { AbortError } from \"./Errors\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Subject } from \"./Subject\";\nimport { Arg, getErrorString, Platform } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\nexport var HubConnectionState;\n(function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n  /** The hub connection is connecting. */\n  HubConnectionState[\"Connecting\"] = \"Connecting\";\n  /** The hub connection is connected. */\n  HubConnectionState[\"Connected\"] = \"Connected\";\n  /** The hub connection is disconnecting. */\n  HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n  /** The hub connection is reconnecting. */\n  HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\nexport var HubConnection = /*#__PURE__*/function () {\n  function HubConnection(connection, logger, protocol, reconnectPolicy) {\n    var _this = this;\n    _classCallCheck(this, HubConnection);\n    this._nextKeepAlive = 0;\n    this._freezeEventListener = function () {\n      _this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n    };\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this._logger = logger;\n    this._protocol = protocol;\n    this.connection = connection;\n    this._reconnectPolicy = reconnectPolicy;\n    this._handshakeProtocol = new HandshakeProtocol();\n    this.connection.onreceive = function (data) {\n      return _this._processIncomingData(data);\n    };\n    this.connection.onclose = function (error) {\n      return _this._connectionClosed(error);\n    };\n    this._callbacks = {};\n    this._methods = {};\n    this._closedCallbacks = [];\n    this._reconnectingCallbacks = [];\n    this._reconnectedCallbacks = [];\n    this._invocationId = 0;\n    this._receivedHandshakeResponse = false;\n    this._connectionState = HubConnectionState.Disconnected;\n    this._connectionStarted = false;\n    this._cachedPingMessage = this._protocol.writeMessage({\n      type: MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n  _createClass(HubConnection, [{\n    key: \"state\",\n    get: /** Indicates the state of the {@link HubConnection} to the server. */\n    function get() {\n      return this._connectionState;\n    }\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\n  }, {\n    key: \"connectionId\",\n    get: function get() {\n      return this.connection ? this.connection.connectionId || null : null;\n    }\n    /** Indicates the url of the {@link HubConnection} to the server. */\n  }, {\n    key: \"baseUrl\",\n    get: function get() {\n      return this.connection.baseUrl || \"\";\n    }\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */,\n    set: function set(url) {\n      if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\n        throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n      }\n      if (!url) {\n        throw new Error(\"The HubConnection url must be a valid url.\");\n      }\n      this.connection.baseUrl = url;\n    }\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._startPromise = this._startWithStateTransitions();\n      return this._startPromise;\n    }\n  }, {\n    key: \"_startWithStateTransitions\",\n    value: function () {\n      var _startWithStateTransitions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this._connectionState !== HubConnectionState.Disconnected)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\")));\n            case 2:\n              this._connectionState = HubConnectionState.Connecting;\n              this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n              _context.prev = 4;\n              _context.next = 7;\n              return this._startInternal();\n            case 7:\n              if (Platform.isBrowser) {\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\n              }\n              this._connectionState = HubConnectionState.Connected;\n              this._connectionStarted = true;\n              this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\n              _context.next = 18;\n              break;\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](4);\n              this._connectionState = HubConnectionState.Disconnected;\n              this._logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\".concat(_context.t0, \"'.\"));\n              return _context.abrupt(\"return\", Promise.reject(_context.t0));\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[4, 13]]);\n      }));\n      function _startWithStateTransitions() {\n        return _startWithStateTransitions2.apply(this, arguments);\n      }\n      return _startWithStateTransitions;\n    }()\n  }, {\n    key: \"_startInternal\",\n    value: function () {\n      var _startInternal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this2 = this;\n        var handshakePromise, handshakeRequest;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this._stopDuringStartError = undefined;\n              this._receivedHandshakeResponse = false;\n              // Set up the promise before any connection is (re)started otherwise it could race with received messages\n              handshakePromise = new Promise(function (resolve, reject) {\n                _this2._handshakeResolver = resolve;\n                _this2._handshakeRejecter = reject;\n              });\n              _context2.next = 5;\n              return this.connection.start(this._protocol.transferFormat);\n            case 5:\n              _context2.prev = 5;\n              handshakeRequest = {\n                protocol: this._protocol.name,\n                version: this._protocol.version\n              };\n              this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\n              _context2.next = 10;\n              return this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\n            case 10:\n              this._logger.log(LogLevel.Information, \"Using HubProtocol '\".concat(this._protocol.name, \"'.\"));\n              // defensively cleanup timeout in case we receive a message from the server before we finish start\n              this._cleanupTimeout();\n              this._resetTimeoutPeriod();\n              this._resetKeepAliveInterval();\n              _context2.next = 16;\n              return handshakePromise;\n            case 16:\n              if (!this._stopDuringStartError) {\n                _context2.next = 18;\n                break;\n              }\n              throw this._stopDuringStartError;\n            case 18:\n              if (this.connection.features.inherentKeepAlive) {\n                _context2.next = 21;\n                break;\n              }\n              _context2.next = 21;\n              return this._sendMessage(this._cachedPingMessage);\n            case 21:\n              _context2.next = 31;\n              break;\n            case 23:\n              _context2.prev = 23;\n              _context2.t0 = _context2[\"catch\"](5);\n              this._logger.log(LogLevel.Debug, \"Hub handshake failed with error '\".concat(_context2.t0, \"' during start(). Stopping HubConnection.\"));\n              this._cleanupTimeout();\n              this._cleanupPingTimer();\n              // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n              // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n              _context2.next = 30;\n              return this.connection.stop(_context2.t0);\n            case 30:\n              throw _context2.t0;\n            case 31:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[5, 23]]);\n      }));\n      function _startInternal() {\n        return _startInternal2.apply(this, arguments);\n      }\n      return _startInternal;\n    }()\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var startPromise;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // Capture the start promise before the connection might be restarted in an onclose callback.\n              startPromise = this._startPromise;\n              this._stopPromise = this._stopInternal();\n              _context3.next = 4;\n              return this._stopPromise;\n            case 4:\n              _context3.prev = 4;\n              _context3.next = 7;\n              return startPromise;\n            case 7:\n              _context3.next = 11;\n              break;\n            case 9:\n              _context3.prev = 9;\n              _context3.t0 = _context3[\"catch\"](4);\n            case 11:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[4, 9]]);\n      }));\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n  }, {\n    key: \"_stopInternal\",\n    value: function _stopInternal(error) {\n      if (this._connectionState === HubConnectionState.Disconnected) {\n        this._logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\".concat(error, \") ignored because it is already in the disconnected state.\"));\n        return Promise.resolve();\n      }\n      if (this._connectionState === HubConnectionState.Disconnecting) {\n        this._logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnecting state.\"));\n        return this._stopPromise;\n      }\n      this._connectionState = HubConnectionState.Disconnecting;\n      this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n      if (this._reconnectDelayHandle) {\n        // We're in a reconnect delay which means the underlying connection is currently already stopped.\n        // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n        // fire the onclose callbacks.\n        this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n        clearTimeout(this._reconnectDelayHandle);\n        this._reconnectDelayHandle = undefined;\n        this._completeClose();\n        return Promise.resolve();\n      }\n      this._cleanupTimeout();\n      this._cleanupPingTimer();\n      this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\n      // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n      // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n      // to the disconnected state if need be before HttpConnection.stop() completes.\n      return this.connection.stop(error);\n    }\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\n  }, {\n    key: \"stream\",\n    value: function stream(methodName) {\n      var _this3 = this;\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      var _this$_replaceStreami = this._replaceStreamingParams(args),\n        _this$_replaceStreami2 = _slicedToArray(_this$_replaceStreami, 2),\n        streams = _this$_replaceStreami2[0],\n        streamIds = _this$_replaceStreami2[1];\n      var invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\n      // eslint-disable-next-line prefer-const\n      var promiseQueue;\n      var subject = new Subject();\n      subject.cancelCallback = function () {\n        var cancelInvocation = _this3._createCancelInvocation(invocationDescriptor.invocationId);\n        delete _this3._callbacks[invocationDescriptor.invocationId];\n        return promiseQueue.then(function () {\n          return _this3._sendWithProtocol(cancelInvocation);\n        });\n      };\n      this._callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          subject.error(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === MessageType.Completion) {\n            if (invocationEvent.error) {\n              subject.error(new Error(invocationEvent.error));\n            } else {\n              subject.complete();\n            }\n          } else {\n            subject.next(invocationEvent.item);\n          }\n        }\n      };\n      promiseQueue = this._sendWithProtocol(invocationDescriptor).catch(function (e) {\n        subject.error(e);\n        delete _this3._callbacks[invocationDescriptor.invocationId];\n      });\n      this._launchStreams(streams, promiseQueue);\n      return subject;\n    }\n  }, {\n    key: \"_sendMessage\",\n    value: function _sendMessage(message) {\n      this._resetKeepAliveInterval();\n      return this.connection.send(message);\n    }\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\n  }, {\n    key: \"_sendWithProtocol\",\n    value: function _sendWithProtocol(message) {\n      return this._sendMessage(this._protocol.writeMessage(message));\n    }\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\n  }, {\n    key: \"send\",\n    value: function send(methodName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      var _this$_replaceStreami3 = this._replaceStreamingParams(args),\n        _this$_replaceStreami4 = _slicedToArray(_this$_replaceStreami3, 2),\n        streams = _this$_replaceStreami4[0],\n        streamIds = _this$_replaceStreami4[1];\n      var sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\n      this._launchStreams(streams, sendPromise);\n      return sendPromise;\n    }\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\n  }, {\n    key: \"invoke\",\n    value: function invoke(methodName) {\n      var _this4 = this;\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      var _this$_replaceStreami5 = this._replaceStreamingParams(args),\n        _this$_replaceStreami6 = _slicedToArray(_this$_replaceStreami5, 2),\n        streams = _this$_replaceStreami6[0],\n        streamIds = _this$_replaceStreami6[1];\n      var invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\n      var p = new Promise(function (resolve, reject) {\n        // invocationId will always have a value for a non-blocking invocation\n        _this4._callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n          if (error) {\n            reject(error);\n            return;\n          } else if (invocationEvent) {\n            // invocationEvent will not be null when an error is not passed to the callback\n            if (invocationEvent.type === MessageType.Completion) {\n              if (invocationEvent.error) {\n                reject(new Error(invocationEvent.error));\n              } else {\n                resolve(invocationEvent.result);\n              }\n            } else {\n              reject(new Error(\"Unexpected message type: \".concat(invocationEvent.type)));\n            }\n          }\n        };\n        var promiseQueue = _this4._sendWithProtocol(invocationDescriptor).catch(function (e) {\n          reject(e);\n          // invocationId will always have a value for a non-blocking invocation\n          delete _this4._callbacks[invocationDescriptor.invocationId];\n        });\n        _this4._launchStreams(streams, promiseQueue);\n      });\n      return p;\n    }\n  }, {\n    key: \"on\",\n    value: function on(methodName, newMethod) {\n      if (!methodName || !newMethod) {\n        return;\n      }\n      methodName = methodName.toLowerCase();\n      if (!this._methods[methodName]) {\n        this._methods[methodName] = [];\n      }\n      // Preventing adding the same handler multiple times.\n      if (this._methods[methodName].indexOf(newMethod) !== -1) {\n        return;\n      }\n      this._methods[methodName].push(newMethod);\n    }\n  }, {\n    key: \"off\",\n    value: function off(methodName, method) {\n      if (!methodName) {\n        return;\n      }\n      methodName = methodName.toLowerCase();\n      var handlers = this._methods[methodName];\n      if (!handlers) {\n        return;\n      }\n      if (method) {\n        var removeIdx = handlers.indexOf(method);\n        if (removeIdx !== -1) {\n          handlers.splice(removeIdx, 1);\n          if (handlers.length === 0) {\n            delete this._methods[methodName];\n          }\n        }\n      } else {\n        delete this._methods[methodName];\n      }\n    }\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\n  }, {\n    key: \"onclose\",\n    value: function onclose(callback) {\n      if (callback) {\n        this._closedCallbacks.push(callback);\n      }\n    }\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\n  }, {\n    key: \"onreconnecting\",\n    value: function onreconnecting(callback) {\n      if (callback) {\n        this._reconnectingCallbacks.push(callback);\n      }\n    }\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\n  }, {\n    key: \"onreconnected\",\n    value: function onreconnected(callback) {\n      if (callback) {\n        this._reconnectedCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"_processIncomingData\",\n    value: function _processIncomingData(data) {\n      this._cleanupTimeout();\n      if (!this._receivedHandshakeResponse) {\n        data = this._processHandshakeResponse(data);\n        this._receivedHandshakeResponse = true;\n      }\n      // Data may have all been read when processing handshake response\n      if (data) {\n        // Parse the messages\n        var messages = this._protocol.parseMessages(data, this._logger);\n        var _iterator = _createForOfIteratorHelper(messages),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var message = _step.value;\n            switch (message.type) {\n              case MessageType.Invocation:\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this._invokeClientMethod(message);\n                break;\n              case MessageType.StreamItem:\n              case MessageType.Completion:\n                {\n                  var callback = this._callbacks[message.invocationId];\n                  if (callback) {\n                    if (message.type === MessageType.Completion) {\n                      delete this._callbacks[message.invocationId];\n                    }\n                    try {\n                      callback(message);\n                    } catch (e) {\n                      this._logger.log(LogLevel.Error, \"Stream callback threw error: \".concat(getErrorString(e)));\n                    }\n                  }\n                  break;\n                }\n              case MessageType.Ping:\n                // Don't care about pings\n                break;\n              case MessageType.Close:\n                {\n                  this._logger.log(LogLevel.Information, \"Close message received from server.\");\n                  var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n                  if (message.allowReconnect === true) {\n                    // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n                    // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this.connection.stop(error);\n                  } else {\n                    // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n                    this._stopPromise = this._stopInternal(error);\n                  }\n                  break;\n                }\n              default:\n                this._logger.log(LogLevel.Warning, \"Invalid message type: \".concat(message.type, \".\"));\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      this._resetTimeoutPeriod();\n    }\n  }, {\n    key: \"_processHandshakeResponse\",\n    value: function _processHandshakeResponse(data) {\n      var responseMessage;\n      var remainingData;\n      try {\n        var _this$_handshakeProto = this._handshakeProtocol.parseHandshakeResponse(data);\n        var _this$_handshakeProto2 = _slicedToArray(_this$_handshakeProto, 2);\n        remainingData = _this$_handshakeProto2[0];\n        responseMessage = _this$_handshakeProto2[1];\n      } catch (e) {\n        var message = \"Error parsing handshake response: \" + e;\n        this._logger.log(LogLevel.Error, message);\n        var error = new Error(message);\n        this._handshakeRejecter(error);\n        throw error;\n      }\n      if (responseMessage.error) {\n        var _message = \"Server returned handshake error: \" + responseMessage.error;\n        this._logger.log(LogLevel.Error, _message);\n        var _error = new Error(_message);\n        this._handshakeRejecter(_error);\n        throw _error;\n      } else {\n        this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\n      }\n      this._handshakeResolver();\n      return remainingData;\n    }\n  }, {\n    key: \"_resetKeepAliveInterval\",\n    value: function _resetKeepAliveInterval() {\n      if (this.connection.features.inherentKeepAlive) {\n        return;\n      }\n      // Set the time we want the next keep alive to be sent\n      // Timer will be setup on next message receive\n      this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\n      this._cleanupPingTimer();\n    }\n  }, {\n    key: \"_resetTimeoutPeriod\",\n    value: function _resetTimeoutPeriod() {\n      var _this5 = this;\n      if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n        // Set the timeout timer\n        this._timeoutHandle = setTimeout(function () {\n          return _this5.serverTimeout();\n        }, this.serverTimeoutInMilliseconds);\n        // Set keepAlive timer if there isn't one\n        if (this._pingServerHandle === undefined) {\n          var nextPing = this._nextKeepAlive - new Date().getTime();\n          if (nextPing < 0) {\n            nextPing = 0;\n          }\n          // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\n          this._pingServerHandle = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (!(_this5._connectionState === HubConnectionState.Connected)) {\n                    _context4.next = 9;\n                    break;\n                  }\n                  _context4.prev = 1;\n                  _context4.next = 4;\n                  return _this5._sendMessage(_this5._cachedPingMessage);\n                case 4:\n                  _context4.next = 9;\n                  break;\n                case 6:\n                  _context4.prev = 6;\n                  _context4.t0 = _context4[\"catch\"](1);\n                  // We don't care about the error. It should be seen elsewhere in the client.\n                  // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n                  _this5._cleanupPingTimer();\n                case 9:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4, null, [[1, 6]]);\n          })), nextPing);\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n  }, {\n    key: \"serverTimeout\",\n    value: function serverTimeout() {\n      // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n      // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n    }\n  }, {\n    key: \"_invokeClientMethod\",\n    value: function () {\n      var _invokeClientMethod2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(invocationMessage) {\n        var methodName, methods, methodsCopy, expectsResponse, res, exception, completionMessage, _iterator2, _step2, m, prevRes;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              methodName = invocationMessage.target.toLowerCase();\n              methods = this._methods[methodName];\n              if (methods) {\n                _context5.next = 9;\n                break;\n              }\n              this._logger.log(LogLevel.Warning, \"No client method with the name '\".concat(methodName, \"' found.\"));\n              // No handlers provided by client but the server is expecting a response still, so we send an error\n              if (!invocationMessage.invocationId) {\n                _context5.next = 8;\n                break;\n              }\n              this._logger.log(LogLevel.Warning, \"No result given for '\".concat(methodName, \"' method and invocation ID '\").concat(invocationMessage.invocationId, \"'.\"));\n              _context5.next = 8;\n              return this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\n            case 8:\n              return _context5.abrupt(\"return\");\n            case 9:\n              // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\n              methodsCopy = methods.slice(); // Server expects a response\n              expectsResponse = invocationMessage.invocationId ? true : false; // We preserve the last result or exception but still call all handlers\n              _iterator2 = _createForOfIteratorHelper(methodsCopy);\n              _context5.prev = 12;\n              _iterator2.s();\n            case 14:\n              if ((_step2 = _iterator2.n()).done) {\n                _context5.next = 31;\n                break;\n              }\n              m = _step2.value;\n              _context5.prev = 16;\n              prevRes = res;\n              _context5.next = 20;\n              return m.apply(this, invocationMessage.arguments);\n            case 20:\n              res = _context5.sent;\n              if (expectsResponse && res && prevRes) {\n                this._logger.log(LogLevel.Error, \"Multiple results provided for '\".concat(methodName, \"'. Sending error to server.\"));\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"Client provided multiple results.\", null);\n              }\n              // Ignore exception if we got a result after, the exception will be logged\n              exception = undefined;\n              _context5.next = 29;\n              break;\n            case 25:\n              _context5.prev = 25;\n              _context5.t0 = _context5[\"catch\"](16);\n              exception = _context5.t0;\n              this._logger.log(LogLevel.Error, \"A callback for the method '\".concat(methodName, \"' threw error '\").concat(_context5.t0, \"'.\"));\n            case 29:\n              _context5.next = 14;\n              break;\n            case 31:\n              _context5.next = 36;\n              break;\n            case 33:\n              _context5.prev = 33;\n              _context5.t1 = _context5[\"catch\"](12);\n              _iterator2.e(_context5.t1);\n            case 36:\n              _context5.prev = 36;\n              _iterator2.f();\n              return _context5.finish(36);\n            case 39:\n              if (!completionMessage) {\n                _context5.next = 44;\n                break;\n              }\n              _context5.next = 42;\n              return this._sendWithProtocol(completionMessage);\n            case 42:\n              _context5.next = 51;\n              break;\n            case 44:\n              if (!expectsResponse) {\n                _context5.next = 50;\n                break;\n              }\n              // If there is an exception that means either no result was given or a handler after a result threw\n              if (exception) {\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"\".concat(exception), null);\n              } else if (res !== undefined) {\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);\n              } else {\n                this._logger.log(LogLevel.Warning, \"No result given for '\".concat(methodName, \"' method and invocation ID '\").concat(invocationMessage.invocationId, \"'.\"));\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null);\n              }\n              _context5.next = 48;\n              return this._sendWithProtocol(completionMessage);\n            case 48:\n              _context5.next = 51;\n              break;\n            case 50:\n              if (res) {\n                this._logger.log(LogLevel.Error, \"Result given for '\".concat(methodName, \"' method but server is not expecting a result.\"));\n              }\n            case 51:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[12, 33, 36, 39], [16, 25]]);\n      }));\n      function _invokeClientMethod(_x) {\n        return _invokeClientMethod2.apply(this, arguments);\n      }\n      return _invokeClientMethod;\n    }()\n  }, {\n    key: \"_connectionClosed\",\n    value: function _connectionClosed(error) {\n      this._logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\".concat(error, \") called while in state \").concat(this._connectionState, \".\"));\n      // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n      this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\n      // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n      // If it has already completed, this should just noop.\n      if (this._handshakeResolver) {\n        this._handshakeResolver();\n      }\n      this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n      this._cleanupTimeout();\n      this._cleanupPingTimer();\n      if (this._connectionState === HubConnectionState.Disconnecting) {\n        this._completeClose(error);\n      } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._reconnect(error);\n      } else if (this._connectionState === HubConnectionState.Connected) {\n        this._completeClose(error);\n      }\n      // If none of the above if conditions were true were called the HubConnection must be in either:\n      // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n      // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n      //    and potentially continue the reconnect() loop.\n      // 3. The Disconnected state in which case we're already done.\n    }\n  }, {\n    key: \"_completeClose\",\n    value: function _completeClose(error) {\n      var _this6 = this;\n      if (this._connectionStarted) {\n        this._connectionState = HubConnectionState.Disconnected;\n        this._connectionStarted = false;\n        if (Platform.isBrowser) {\n          window.document.removeEventListener(\"freeze\", this._freezeEventListener);\n        }\n        try {\n          this._closedCallbacks.forEach(function (c) {\n            return c.apply(_this6, [error]);\n          });\n        } catch (e) {\n          this._logger.log(LogLevel.Error, \"An onclose callback called with error '\".concat(error, \"' threw error '\").concat(e, \"'.\"));\n        }\n      }\n    }\n  }, {\n    key: \"_reconnect\",\n    value: function () {\n      var _reconnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(error) {\n        var _this7 = this;\n        var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              reconnectStartTime = Date.now();\n              previousReconnectAttempts = 0;\n              retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n              nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n              if (!(nextRetryDelay === null)) {\n                _context6.next = 8;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n              this._completeClose(error);\n              return _context6.abrupt(\"return\");\n            case 8:\n              this._connectionState = HubConnectionState.Reconnecting;\n              if (error) {\n                this._logger.log(LogLevel.Information, \"Connection reconnecting because of error '\".concat(error, \"'.\"));\n              } else {\n                this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\n              }\n              if (!(this._reconnectingCallbacks.length !== 0)) {\n                _context6.next = 15;\n                break;\n              }\n              try {\n                this._reconnectingCallbacks.forEach(function (c) {\n                  return c.apply(_this7, [error]);\n                });\n              } catch (e) {\n                this._logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\".concat(error, \"' threw error '\").concat(e, \"'.\"));\n              }\n              // Exit early if an onreconnecting callback called connection.stop().\n              if (!(this._connectionState !== HubConnectionState.Reconnecting)) {\n                _context6.next = 15;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n              return _context6.abrupt(\"return\");\n            case 15:\n              if (!(nextRetryDelay !== null)) {\n                _context6.next = 43;\n                break;\n              }\n              this._logger.log(LogLevel.Information, \"Reconnect attempt number \".concat(previousReconnectAttempts, \" will start in \").concat(nextRetryDelay, \" ms.\"));\n              _context6.next = 19;\n              return new Promise(function (resolve) {\n                _this7._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n              });\n            case 19:\n              this._reconnectDelayHandle = undefined;\n              if (!(this._connectionState !== HubConnectionState.Reconnecting)) {\n                _context6.next = 23;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n              return _context6.abrupt(\"return\");\n            case 23:\n              _context6.prev = 23;\n              _context6.next = 26;\n              return this._startInternal();\n            case 26:\n              this._connectionState = HubConnectionState.Connected;\n              this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\n              if (this._reconnectedCallbacks.length !== 0) {\n                try {\n                  this._reconnectedCallbacks.forEach(function (c) {\n                    return c.apply(_this7, [_this7.connection.connectionId]);\n                  });\n                } catch (e) {\n                  this._logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\".concat(this.connection.connectionId, \"; threw error '\").concat(e, \"'.\"));\n                }\n              }\n              return _context6.abrupt(\"return\");\n            case 32:\n              _context6.prev = 32;\n              _context6.t0 = _context6[\"catch\"](23);\n              this._logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\".concat(_context6.t0, \"'.\"));\n              if (!(this._connectionState !== HubConnectionState.Reconnecting)) {\n                _context6.next = 39;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Connection moved to the '\".concat(this._connectionState, \"' from the reconnecting state during reconnect attempt. Done reconnecting.\"));\n              // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\n              if (this._connectionState === HubConnectionState.Disconnecting) {\n                this._completeClose();\n              }\n              return _context6.abrupt(\"return\");\n            case 39:\n              retryError = _context6.t0 instanceof Error ? _context6.t0 : new Error(_context6.t0.toString());\n              nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n            case 41:\n              _context6.next = 15;\n              break;\n            case 43:\n              this._logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \".concat(Date.now() - reconnectStartTime, \" ms and \").concat(previousReconnectAttempts, \" failed attempts. Connection disconnecting.\"));\n              this._completeClose();\n            case 45:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[23, 32]]);\n      }));\n      function _reconnect(_x2) {\n        return _reconnect2.apply(this, arguments);\n      }\n      return _reconnect;\n    }()\n  }, {\n    key: \"_getNextRetryDelay\",\n    value: function _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\n      try {\n        return this._reconnectPolicy.nextRetryDelayInMilliseconds({\n          elapsedMilliseconds: elapsedMilliseconds,\n          previousRetryCount: previousRetryCount,\n          retryReason: retryReason\n        });\n      } catch (e) {\n        this._logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\".concat(previousRetryCount, \", \").concat(elapsedMilliseconds, \") threw error '\").concat(e, \"'.\"));\n        return null;\n      }\n    }\n  }, {\n    key: \"_cancelCallbacksWithError\",\n    value: function _cancelCallbacksWithError(error) {\n      var _this8 = this;\n      var callbacks = this._callbacks;\n      this._callbacks = {};\n      Object.keys(callbacks).forEach(function (key) {\n        var callback = callbacks[key];\n        try {\n          callback(null, error);\n        } catch (e) {\n          _this8._logger.log(LogLevel.Error, \"Stream 'error' callback called with '\".concat(error, \"' threw error: \").concat(getErrorString(e)));\n        }\n      });\n    }\n  }, {\n    key: \"_cleanupPingTimer\",\n    value: function _cleanupPingTimer() {\n      if (this._pingServerHandle) {\n        clearTimeout(this._pingServerHandle);\n        this._pingServerHandle = undefined;\n      }\n    }\n  }, {\n    key: \"_cleanupTimeout\",\n    value: function _cleanupTimeout() {\n      if (this._timeoutHandle) {\n        clearTimeout(this._timeoutHandle);\n      }\n    }\n  }, {\n    key: \"_createInvocation\",\n    value: function _createInvocation(methodName, args, nonblocking, streamIds) {\n      if (nonblocking) {\n        if (streamIds.length !== 0) {\n          return {\n            arguments: args,\n            streamIds: streamIds,\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        } else {\n          return {\n            arguments: args,\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        }\n      } else {\n        var invocationId = this._invocationId;\n        this._invocationId++;\n        if (streamIds.length !== 0) {\n          return {\n            arguments: args,\n            invocationId: invocationId.toString(),\n            streamIds: streamIds,\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        } else {\n          return {\n            arguments: args,\n            invocationId: invocationId.toString(),\n            target: methodName,\n            type: MessageType.Invocation\n          };\n        }\n      }\n    }\n  }, {\n    key: \"_launchStreams\",\n    value: function _launchStreams(streams, promiseQueue) {\n      var _this9 = this;\n      if (streams.length === 0) {\n        return;\n      }\n      // Synchronize stream data so they arrive in-order on the server\n      if (!promiseQueue) {\n        promiseQueue = Promise.resolve();\n      }\n      // We want to iterate over the keys, since the keys are the stream ids\n      // eslint-disable-next-line guard-for-in\n      var _loop = function _loop(streamId) {\n        streams[streamId].subscribe({\n          complete: function complete() {\n            promiseQueue = promiseQueue.then(function () {\n              return _this9._sendWithProtocol(_this9._createCompletionMessage(streamId));\n            });\n          },\n          error: function error(err) {\n            var message;\n            if (err instanceof Error) {\n              message = err.message;\n            } else if (err && err.toString) {\n              message = err.toString();\n            } else {\n              message = \"Unknown error\";\n            }\n            promiseQueue = promiseQueue.then(function () {\n              return _this9._sendWithProtocol(_this9._createCompletionMessage(streamId, message));\n            });\n          },\n          next: function next(item) {\n            promiseQueue = promiseQueue.then(function () {\n              return _this9._sendWithProtocol(_this9._createStreamItemMessage(streamId, item));\n            });\n          }\n        });\n      };\n      for (var streamId in streams) {\n        _loop(streamId);\n      }\n    }\n  }, {\n    key: \"_replaceStreamingParams\",\n    value: function _replaceStreamingParams(args) {\n      var streams = [];\n      var streamIds = [];\n      for (var i = 0; i < args.length; i++) {\n        var argument = args[i];\n        if (this._isObservable(argument)) {\n          var streamId = this._invocationId;\n          this._invocationId++;\n          // Store the stream for later use\n          streams[streamId] = argument;\n          streamIds.push(streamId.toString());\n          // remove stream from args\n          args.splice(i, 1);\n        }\n      }\n      return [streams, streamIds];\n    }\n  }, {\n    key: \"_isObservable\",\n    value: function _isObservable(arg) {\n      // This allows other stream implementations to just work (like rxjs)\n      return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n    }\n  }, {\n    key: \"_createStreamInvocation\",\n    value: function _createStreamInvocation(methodName, args, streamIds) {\n      var invocationId = this._invocationId;\n      this._invocationId++;\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.StreamInvocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: MessageType.StreamInvocation\n        };\n      }\n    }\n  }, {\n    key: \"_createCancelInvocation\",\n    value: function _createCancelInvocation(id) {\n      return {\n        invocationId: id,\n        type: MessageType.CancelInvocation\n      };\n    }\n  }, {\n    key: \"_createStreamItemMessage\",\n    value: function _createStreamItemMessage(id, item) {\n      return {\n        invocationId: id,\n        item: item,\n        type: MessageType.StreamItem\n      };\n    }\n  }, {\n    key: \"_createCompletionMessage\",\n    value: function _createCompletionMessage(id, error, result) {\n      if (error) {\n        return {\n          error: error,\n          invocationId: id,\n          type: MessageType.Completion\n        };\n      }\n      return {\n        invocationId: id,\n        result: result,\n        type: MessageType.Completion\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(connection, logger, protocol, reconnectPolicy) {\n      return new HubConnection(connection, logger, protocol, reconnectPolicy);\n    }\n  }]);\n  return HubConnection;\n}();","map":{"version":3,"names":["HandshakeProtocol","AbortError","MessageType","LogLevel","Subject","Arg","getErrorString","Platform","DEFAULT_TIMEOUT_IN_MS","DEFAULT_PING_INTERVAL_IN_MS","HubConnectionState","HubConnection","connection","logger","protocol","reconnectPolicy","_this","_classCallCheck","_nextKeepAlive","_freezeEventListener","_logger","log","Warning","isRequired","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","_protocol","_reconnectPolicy","_handshakeProtocol","onreceive","data","_processIncomingData","onclose","error","_connectionClosed","_callbacks","_methods","_closedCallbacks","_reconnectingCallbacks","_reconnectedCallbacks","_invocationId","_receivedHandshakeResponse","_connectionState","Disconnected","_connectionStarted","_cachedPingMessage","writeMessage","type","Ping","_createClass","key","get","connectionId","baseUrl","set","url","Reconnecting","Error","value","start","_startPromise","_startWithStateTransitions","_startWithStateTransitions2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","Promise","reject","Connecting","Debug","_startInternal","isBrowser","window","document","addEventListener","Connected","t0","concat","stop","apply","arguments","_startInternal2","_callee2","_this2","handshakePromise","handshakeRequest","_callee2$","_context2","_stopDuringStartError","undefined","resolve","_handshakeResolver","_handshakeRejecter","transferFormat","name","version","_sendMessage","writeHandshakeRequest","Information","_cleanupTimeout","_resetTimeoutPeriod","_resetKeepAliveInterval","features","inherentKeepAlive","_cleanupPingTimer","_stop","_callee3","startPromise","_callee3$","_context3","_stopPromise","_stopInternal","Disconnecting","_reconnectDelayHandle","clearTimeout","_completeClose","stream","methodName","_this3","_len","length","args","Array","_key","_this$_replaceStreami","_replaceStreamingParams","_this$_replaceStreami2","_slicedToArray","streams","streamIds","invocationDescriptor","_createStreamInvocation","promiseQueue","subject","cancelCallback","cancelInvocation","_createCancelInvocation","invocationId","then","_sendWithProtocol","invocationEvent","Completion","complete","item","catch","e","_launchStreams","message","send","_len2","_key2","_this$_replaceStreami3","_this$_replaceStreami4","sendPromise","_createInvocation","invoke","_this4","_len3","_key3","_this$_replaceStreami5","_this$_replaceStreami6","p","result","on","newMethod","toLowerCase","indexOf","push","off","method","handlers","removeIdx","splice","callback","onreconnecting","onreconnected","_processHandshakeResponse","messages","parseMessages","_iterator","_createForOfIteratorHelper","_step","s","n","done","Invocation","_invokeClientMethod","StreamItem","Close","allowReconnect","err","f","responseMessage","remainingData","_this$_handshakeProto","parseHandshakeResponse","_this$_handshakeProto2","Date","getTime","_this5","_timeoutHandle","setTimeout","serverTimeout","_pingServerHandle","nextPing","_callee4","_callee4$","_context4","_invokeClientMethod2","_callee5","invocationMessage","methods","methodsCopy","expectsResponse","res","exception","completionMessage","_iterator2","_step2","m","prevRes","_callee5$","_context5","target","_createCompletionMessage","slice","sent","t1","finish","_x","_cancelCallbacksWithError","_reconnect","_this6","removeEventListener","forEach","c","_reconnect2","_callee6","_this7","reconnectStartTime","previousReconnectAttempts","retryError","nextRetryDelay","_callee6$","_context6","now","_getNextRetryDelay","toString","_x2","previousRetryCount","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","_this8","callbacks","Object","keys","nonblocking","_this9","_loop","streamId","subscribe","_createStreamItemMessage","i","argument","_isObservable","arg","StreamInvocation","id","CancelInvocation","create"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/HubConnection.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { AbortError } from \"./Errors\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly _cachedPingMessage: string | ArrayBuffer;\r\n    // Needs to not start with _ for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private readonly connection: IConnection;\r\n    private readonly _logger: ILogger;\r\n    private readonly _reconnectPolicy?: IRetryPolicy;\r\n    private _protocol: IHubProtocol;\r\n    private _handshakeProtocol: HandshakeProtocol;\r\n    private _callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private _methods: { [name: string]: (((...args: any[]) => void) | ((...args: any[]) => any))[] };\r\n    private _invocationId: number;\r\n\r\n    private _closedCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectingCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectedCallbacks: ((connectionId?: string) => void)[];\r\n\r\n    private _receivedHandshakeResponse: boolean;\r\n    private _handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private _handshakeRejecter!: (reason?: any) => void;\r\n    private _stopDuringStartError?: Error;\r\n\r\n    private _connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private _startPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _nextKeepAlive: number = 0;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private _reconnectDelayHandle?: any;\r\n    private _timeoutHandle?: any;\r\n    private _pingServerHandle?: any;\r\n\r\n    private _freezeEventListener = () =>\r\n    {\r\n        this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n    };\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     * The ping will happen at most as often as the server pings.\r\n     * If the server pings every 5 seconds, a value lower than 5 will ping every 5 seconds.\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this._processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this._connectionClosed(error);\r\n\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this._connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n\r\n    private async _startWithStateTransitions(): Promise<void> {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this._startInternal();\r\n\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this._protocol.transferFormat);\r\n\r\n        try {\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this._protocol.name,\r\n                version: this._protocol.version,\r\n            };\r\n\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n\r\n            if (!this.connection.features.inherentKeepAlive) {\r\n                await this._sendMessage(this._cachedPingMessage);\r\n            }\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private _stopInternal(error?: Error): Promise<void> {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise!;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue: Promise<void>;\r\n\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this._launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private _sendMessage(message: any) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private _sendWithProtocol(message: any) {\r\n        return this._sendMessage(this._protocol.writeMessage(message));\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n\r\n        this._launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this._callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => any): void\r\n    public on(methodName: string, newMethod: (...args: any[]) => void): void {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this._methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void): void {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private _processIncomingData(data: any) {\r\n        this._cleanupTimeout();\r\n\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                        this._invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            } catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._resetTimeoutPeriod();\r\n    }\r\n\r\n    private _processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n\r\n        this._cleanupPingTimer();\r\n    }\r\n\r\n    private _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined)\r\n            {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        } catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private async _invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methodName = invocationMessage.target.toLowerCase();\r\n        const methods = this._methods[methodName];\r\n        if (!methods) {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);\r\n\r\n            // No handlers provided by client but the server is expecting a response still, so we send an error\r\n            if (invocationMessage.invocationId) {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\r\n        const methodsCopy = methods.slice();\r\n\r\n        // Server expects a response\r\n        const expectsResponse = invocationMessage.invocationId ? true : false;\r\n        // We preserve the last result or exception but still call all handlers\r\n        let res;\r\n        let exception;\r\n        let completionMessage;\r\n        for (const m of methodsCopy) {\r\n            try {\r\n                const prevRes = res;\r\n                res = await m.apply(this, invocationMessage.arguments);\r\n                if (expectsResponse && res && prevRes) {\r\n                    this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\r\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, `Client provided multiple results.`, null);\r\n                }\r\n                // Ignore exception if we got a result after, the exception will be logged\r\n                exception = undefined;\r\n            } catch (e) {\r\n                exception = e;\r\n                this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\r\n            }\r\n        }\r\n        if (completionMessage) {\r\n            await this._sendWithProtocol(completionMessage);\r\n        } else if (expectsResponse) {\r\n            // If there is an exception that means either no result was given or a handler after a result threw\r\n            if (exception) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, `${exception}`, null);\r\n            } else if (res !== undefined) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, null, res);\r\n            } else {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, \"Client didn't provide a result.\", null);\r\n            }\r\n            await this._sendWithProtocol(completionMessage);\r\n        } else {\r\n            if (res) {\r\n                this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _connectionClosed(error?: Error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private _completeClose(error?: Error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this._startInternal();\r\n\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState as any === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this._completeClose();\r\n    }\r\n\r\n    private _getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this._reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private _cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                try {\r\n                    callback(null, error);\r\n                } catch (e) {\r\n                    this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n                }\r\n            });\r\n    }\r\n\r\n    private _cleanupPingTimer(): void {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n\r\n    private _cleanupTimeout(): void {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private _createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _launchStreams(streams: IStreamResult<any>[], promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private _replaceStreamingParams(args: any[]): [IStreamResult<any>[], string[]] {\r\n        const streams: IStreamResult<any>[] = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private _isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private _createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private _createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private _createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private _createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}