{"ast":null,"code":"import _regeneratorRuntime from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\n/** @private */\nexport var WebSocketTransport = /*#__PURE__*/function () {\n  function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    _classCallCheck(this, WebSocketTransport);\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n  _createClass(WebSocketTransport, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, transferFormat) {\n        var _this = this;\n        var token;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              Arg.isRequired(url, \"url\");\n              Arg.isRequired(transferFormat, \"transferFormat\");\n              Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n              this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n              if (!this._accessTokenFactory) {\n                _context.next = 8;\n                break;\n              }\n              _context.next = 7;\n              return this._accessTokenFactory();\n            case 7:\n              token = _context.sent;\n            case 8:\n              return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                url = url.replace(/^http/, \"ws\");\n                var webSocket;\n                var cookies = _this._httpClient.getCookieString(url);\n                var opened = false;\n                if (Platform.isNode || Platform.isReactNative) {\n                  var headers = {};\n                  var _getUserAgentHeader = getUserAgentHeader(),\n                    _getUserAgentHeader2 = _slicedToArray(_getUserAgentHeader, 2),\n                    name = _getUserAgentHeader2[0],\n                    value = _getUserAgentHeader2[1];\n                  headers[name] = value;\n                  if (token) {\n                    headers[HeaderNames.Authorization] = \"Bearer \".concat(token);\n                  }\n                  if (cookies) {\n                    headers[HeaderNames.Cookie] = cookies;\n                  }\n                  // Only pass headers when in non-browser environments\n                  webSocket = new _this._webSocketConstructor(url, undefined, {\n                    headers: _objectSpread(_objectSpread({}, headers), _this._headers)\n                  });\n                } else {\n                  if (token) {\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(token));\n                  }\n                }\n                if (!webSocket) {\n                  // Chrome is not happy with passing 'undefined' as protocol\n                  webSocket = new _this._webSocketConstructor(url);\n                }\n                if (transferFormat === TransferFormat.Binary) {\n                  webSocket.binaryType = \"arraybuffer\";\n                }\n                webSocket.onopen = function (_event) {\n                  _this._logger.log(LogLevel.Information, \"WebSocket connected to \".concat(url, \".\"));\n                  _this._webSocket = webSocket;\n                  opened = true;\n                  resolve();\n                };\n                webSocket.onerror = function (event) {\n                  var error = null;\n                  // ErrorEvent is a browser only type we need to check if the type exists before using it\n                  if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                    error = event.error;\n                  } else {\n                    error = \"There was an error with the transport\";\n                  }\n                  _this._logger.log(LogLevel.Information, \"(WebSockets transport) \".concat(error, \".\"));\n                };\n                webSocket.onmessage = function (message) {\n                  _this._logger.log(LogLevel.Trace, \"(WebSockets transport) data received. \".concat(getDataDetail(message.data, _this._logMessageContent), \".\"));\n                  if (_this.onreceive) {\n                    try {\n                      _this.onreceive(message.data);\n                    } catch (error) {\n                      _this._close(error);\n                      return;\n                    }\n                  }\n                };\n                webSocket.onclose = function (event) {\n                  // Don't call close handler if connection was never established\n                  // We'll reject the connect call instead\n                  if (opened) {\n                    _this._close(event);\n                  } else {\n                    var error = null;\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                      error = event.error;\n                    } else {\n                      error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n                    }\n                    reject(new Error(error));\n                  }\n                };\n              }));\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) sending data. \".concat(getDataDetail(data, this._logMessageContent), \".\"));\n        this._webSocket.send(data);\n        return Promise.resolve();\n      }\n      return Promise.reject(\"WebSocket is not in the OPEN state\");\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._webSocket) {\n        // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n        // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n        this._close(undefined);\n      }\n      return Promise.resolve();\n    }\n  }, {\n    key: \"_close\",\n    value: function _close(event) {\n      // webSocket will be null if the transport did not start successfully\n      if (this._webSocket) {\n        // Clear websocket handlers because we are considering the socket closed now\n        this._webSocket.onclose = function () {};\n        this._webSocket.onmessage = function () {};\n        this._webSocket.onerror = function () {};\n        this._webSocket.close();\n        this._webSocket = undefined;\n      }\n      this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n      if (this.onclose) {\n        if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n          this.onclose(new Error(\"WebSocket closed with status code: \".concat(event.code, \" (\").concat(event.reason || \"no reason given\", \").\")));\n        } else if (event instanceof Error) {\n          this.onclose(event);\n        } else {\n          this.onclose();\n        }\n      }\n    }\n  }, {\n    key: \"_isCloseEvent\",\n    value: function _isCloseEvent(event) {\n      return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n    }\n  }]);\n  return WebSocketTransport;\n}();","map":{"version":3,"names":["HeaderNames","LogLevel","TransferFormat","Arg","getDataDetail","getUserAgentHeader","Platform","WebSocketTransport","httpClient","accessTokenFactory","logger","logMessageContent","webSocketConstructor","headers","_classCallCheck","_logger","_accessTokenFactory","_logMessageContent","_webSocketConstructor","_httpClient","onreceive","onclose","_headers","_createClass","key","value","_connect","_asyncToGenerator","_regeneratorRuntime","mark","_callee","url","transferFormat","_this","token","wrap","_callee$","_context","prev","next","isRequired","isIn","log","Trace","sent","abrupt","Promise","resolve","reject","replace","webSocket","cookies","getCookieString","opened","isNode","isReactNative","_getUserAgentHeader","_getUserAgentHeader2","_slicedToArray","name","Authorization","concat","Cookie","undefined","_objectSpread","indexOf","encodeURIComponent","Binary","binaryType","onopen","_event","Information","_webSocket","onerror","event","error","ErrorEvent","onmessage","message","data","_close","Error","stop","connect","_x","_x2","apply","arguments","send","readyState","OPEN","close","_isCloseEvent","wasClean","code","reason"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/WebSocketTransport.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly _logger: ILogger;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logMessageContent: boolean;\r\n    private readonly _webSocketConstructor: WebSocketConstructor;\r\n    private readonly _httpClient: HttpClient;\r\n    private _webSocket?: WebSocket;\r\n    private _headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        let token: string;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers: {[k: string]: string} = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else\r\n            {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            webSocket.onopen = (_event: Event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the endpoint may not be a SignalR endpoint,\"\r\n                        + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => {};\r\n            this._webSocket.onmessage = () => {};\r\n            this._webSocket.onerror = () => {};\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}