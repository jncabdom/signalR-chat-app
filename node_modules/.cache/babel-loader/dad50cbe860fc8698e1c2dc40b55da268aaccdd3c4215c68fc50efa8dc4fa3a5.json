{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/nico/expero/toolkit/signalR-test/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\nimport { LogLevel } from \"./ILogger\";\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nvar MAX_REDIRECTS = 100;\n/** @private */\nexport var HttpConnection = /*#__PURE__*/function () {\n  function HttpConnection(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, HttpConnection);\n    this._stopPromiseResolver = function () {};\n    this.features = {};\n    this._negotiateVersion = 1;\n    Arg.isRequired(url, \"url\");\n    this._logger = createLogger(options.logger);\n    this.baseUrl = this._resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n    if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n      options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n    } else {\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    }\n    options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\n    var webSocketModule = null;\n    var eventSourceModule = null;\n    if (Platform.isNode && typeof require !== \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      webSocketModule = requireFunc(\"ws\");\n      eventSourceModule = requireFunc(\"eventsource\");\n    }\n    if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (Platform.isNode && !options.WebSocket) {\n      if (webSocketModule) {\n        options.WebSocket = webSocketModule;\n      }\n    }\n    if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (Platform.isNode && !options.EventSource) {\n      if (typeof eventSourceModule !== \"undefined\") {\n        options.EventSource = eventSourceModule;\n      }\n    }\n    this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\n    this._connectionState = \"Disconnected\" /* Disconnected */;\n    this._connectionStarted = false;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  _createClass(HttpConnection, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(transferFormat) {\n        var message, _message;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              transferFormat = transferFormat || TransferFormat.Binary;\n              Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n              this._logger.log(LogLevel.Debug, \"Starting connection with transfer format '\".concat(TransferFormat[transferFormat], \"'.\"));\n              if (!(this._connectionState !== \"Disconnected\" /* Disconnected */)) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\", Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\")));\n            case 5:\n              this._connectionState = \"Connecting\" /* Connecting */;\n              this._startInternalPromise = this._startInternal(transferFormat);\n              _context.next = 9;\n              return this._startInternalPromise;\n            case 9:\n              if (!(this._connectionState === \"Disconnecting\" /* Disconnecting */)) {\n                _context.next = 17;\n                break;\n              }\n              // stop() was called and transitioned the client into the Disconnecting state.\n              message = \"Failed to start the HttpConnection before stop() was called.\";\n              this._logger.log(LogLevel.Error, message);\n              // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n              _context.next = 14;\n              return this._stopPromise;\n            case 14:\n              return _context.abrupt(\"return\", Promise.reject(new AbortError(message)));\n            case 17:\n              if (!(this._connectionState !== \"Connected\" /* Connected */)) {\n                _context.next = 21;\n                break;\n              }\n              // stop() was called and transitioned the client into the Disconnecting state.\n              _message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n              this._logger.log(LogLevel.Error, _message);\n              return _context.abrupt(\"return\", Promise.reject(new AbortError(_message)));\n            case 21:\n              this._connectionStarted = true;\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start(_x) {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (this._connectionState !== \"Connected\" /* Connected */) {\n        return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n      }\n      if (!this._sendQueue) {\n        this._sendQueue = new TransportSendQueue(this.transport);\n      }\n      // Transport will not be null if state is connected\n      return this._sendQueue.send(data);\n    }\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(error) {\n        var _this = this;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this._connectionState === \"Disconnected\" /* Disconnected */)) {\n                _context2.next = 3;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnected state.\"));\n              return _context2.abrupt(\"return\", Promise.resolve());\n            case 3:\n              if (!(this._connectionState === \"Disconnecting\" /* Disconnecting */)) {\n                _context2.next = 6;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\".concat(error, \") ignored because the connection is already in the disconnecting state.\"));\n              return _context2.abrupt(\"return\", this._stopPromise);\n            case 6:\n              this._connectionState = \"Disconnecting\" /* Disconnecting */;\n              this._stopPromise = new Promise(function (resolve) {\n                // Don't complete stop() until stopConnection() completes.\n                _this._stopPromiseResolver = resolve;\n              });\n              // stopInternal should never throw so just observe it.\n              _context2.next = 10;\n              return this._stopInternal(error);\n            case 10:\n              _context2.next = 12;\n              return this._stopPromise;\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function stop(_x2) {\n        return _stop.apply(this, arguments);\n      }\n      return stop;\n    }()\n  }, {\n    key: \"_stopInternal\",\n    value: function () {\n      var _stopInternal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(error) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // Set error as soon as possible otherwise there is a race between\n              // the transport closing and providing an error and the error from a close message\n              // We would prefer the close message error.\n              this._stopError = error;\n              _context3.prev = 1;\n              _context3.next = 4;\n              return this._startInternalPromise;\n            case 4:\n              _context3.next = 8;\n              break;\n            case 6:\n              _context3.prev = 6;\n              _context3.t0 = _context3[\"catch\"](1);\n            case 8:\n              if (!this.transport) {\n                _context3.next = 21;\n                break;\n              }\n              _context3.prev = 9;\n              _context3.next = 12;\n              return this.transport.stop();\n            case 12:\n              _context3.next = 18;\n              break;\n            case 14:\n              _context3.prev = 14;\n              _context3.t1 = _context3[\"catch\"](9);\n              this._logger.log(LogLevel.Error, \"HttpConnection.transport.stop() threw error '\".concat(_context3.t1, \"'.\"));\n              this._stopConnection();\n            case 18:\n              this.transport = undefined;\n              _context3.next = 22;\n              break;\n            case 21:\n              this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 6], [9, 14]]);\n      }));\n      function _stopInternal(_x3) {\n        return _stopInternal2.apply(this, arguments);\n      }\n      return _stopInternal;\n    }()\n  }, {\n    key: \"_startInternal\",\n    value: function () {\n      var _startInternal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transferFormat) {\n        var _this2 = this;\n        var url, negotiateResponse, redirects, _loop;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              // Store the original base url and the access token factory since they may change\n              // as part of negotiating\n              url = this.baseUrl;\n              this._accessTokenFactory = this._options.accessTokenFactory;\n              this._httpClient._accessTokenFactory = this._accessTokenFactory;\n              _context5.prev = 3;\n              if (!this._options.skipNegotiation) {\n                _context5.next = 14;\n                break;\n              }\n              if (!(this._options.transport === HttpTransportType.WebSockets)) {\n                _context5.next = 11;\n                break;\n              }\n              // No need to add a connection ID in this case\n              this.transport = this._constructTransport(HttpTransportType.WebSockets);\n              // We should just call connect directly in this case.\n              // No fallback or negotiate in this case.\n              _context5.next = 9;\n              return this._startTransport(url, transferFormat);\n            case 9:\n              _context5.next = 12;\n              break;\n            case 11:\n              throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n            case 12:\n              _context5.next = 23;\n              break;\n            case 14:\n              negotiateResponse = null;\n              redirects = 0;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var accessToken;\n                return _regeneratorRuntime().wrap(function _loop$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return _this2._getNegotiationResponse(url);\n                    case 2:\n                      negotiateResponse = _context4.sent;\n                      if (!(_this2._connectionState === \"Disconnecting\" /* Disconnecting */ || _this2._connectionState === \"Disconnected\" /* Disconnected */)) {\n                        _context4.next = 5;\n                        break;\n                      }\n                      throw new AbortError(\"The connection was stopped during negotiation.\");\n                    case 5:\n                      if (!negotiateResponse.error) {\n                        _context4.next = 7;\n                        break;\n                      }\n                      throw new Error(negotiateResponse.error);\n                    case 7:\n                      if (!negotiateResponse.ProtocolVersion) {\n                        _context4.next = 9;\n                        break;\n                      }\n                      throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    case 9:\n                      if (negotiateResponse.url) {\n                        url = negotiateResponse.url;\n                      }\n                      if (negotiateResponse.accessToken) {\n                        // Replace the current access token factory with one that uses\n                        // the returned access token\n                        accessToken = negotiateResponse.accessToken;\n                        _this2._accessTokenFactory = function () {\n                          return accessToken;\n                        };\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\n                        _this2._httpClient._accessToken = accessToken;\n                        _this2._httpClient._accessTokenFactory = undefined;\n                      }\n                      redirects++;\n                    case 12:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _loop);\n              });\n            case 17:\n              return _context5.delegateYield(_loop(), \"t0\", 18);\n            case 18:\n              if (negotiateResponse.url && redirects < MAX_REDIRECTS) {\n                _context5.next = 17;\n                break;\n              }\n            case 19:\n              if (!(redirects === MAX_REDIRECTS && negotiateResponse.url)) {\n                _context5.next = 21;\n                break;\n              }\n              throw new Error(\"Negotiate redirection limit exceeded.\");\n            case 21:\n              _context5.next = 23;\n              return this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\n            case 23:\n              if (this.transport instanceof LongPollingTransport) {\n                this.features.inherentKeepAlive = true;\n              }\n              if (this._connectionState === \"Connecting\" /* Connecting */) {\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\n                this._connectionState = \"Connected\" /* Connected */;\n              }\n              // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\n              // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\n              // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\n              _context5.next = 34;\n              break;\n            case 27:\n              _context5.prev = 27;\n              _context5.t1 = _context5[\"catch\"](3);\n              this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + _context5.t1);\n              this._connectionState = \"Disconnected\" /* Disconnected */;\n              this.transport = undefined;\n              // if start fails, any active calls to stop assume that start will complete the stop promise\n              this._stopPromiseResolver();\n              return _context5.abrupt(\"return\", Promise.reject(_context5.t1));\n            case 34:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this, [[3, 27]]);\n      }));\n      function _startInternal(_x4) {\n        return _startInternal2.apply(this, arguments);\n      }\n      return _startInternal;\n    }()\n  }, {\n    key: \"_getNegotiationResponse\",\n    value: function () {\n      var _getNegotiationResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url) {\n        var headers, _getUserAgentHeader, _getUserAgentHeader2, name, value, negotiateUrl, response, negotiateResponse, errorMessage;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              headers = {};\n              _getUserAgentHeader = getUserAgentHeader(), _getUserAgentHeader2 = _slicedToArray(_getUserAgentHeader, 2), name = _getUserAgentHeader2[0], value = _getUserAgentHeader2[1];\n              headers[name] = value;\n              negotiateUrl = this._resolveNegotiateUrl(url);\n              this._logger.log(LogLevel.Debug, \"Sending negotiation request: \".concat(negotiateUrl, \".\"));\n              _context6.prev = 5;\n              _context6.next = 8;\n              return this._httpClient.post(negotiateUrl, {\n                content: \"\",\n                headers: _objectSpread(_objectSpread({}, headers), this._options.headers),\n                timeout: this._options.timeout,\n                withCredentials: this._options.withCredentials\n              });\n            case 8:\n              response = _context6.sent;\n              if (!(response.statusCode !== 200)) {\n                _context6.next = 11;\n                break;\n              }\n              return _context6.abrupt(\"return\", Promise.reject(new Error(\"Unexpected status code returned from negotiate '\".concat(response.statusCode, \"'\"))));\n            case 11:\n              negotiateResponse = JSON.parse(response.content);\n              if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n                // Negotiate version 0 doesn't use connectionToken\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\n              }\n              return _context6.abrupt(\"return\", negotiateResponse);\n            case 16:\n              _context6.prev = 16;\n              _context6.t0 = _context6[\"catch\"](5);\n              errorMessage = \"Failed to complete negotiation with the server: \" + _context6.t0;\n              if (_context6.t0 instanceof HttpError) {\n                if (_context6.t0.statusCode === 404) {\n                  errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\n                }\n              }\n              this._logger.log(LogLevel.Error, errorMessage);\n              return _context6.abrupt(\"return\", Promise.reject(new FailedToNegotiateWithServerError(errorMessage)));\n            case 22:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this, [[5, 16]]);\n      }));\n      function _getNegotiationResponse(_x5) {\n        return _getNegotiationResponse2.apply(this, arguments);\n      }\n      return _getNegotiationResponse;\n    }()\n  }, {\n    key: \"_createConnectUrl\",\n    value: function _createConnectUrl(url, connectionToken) {\n      if (!connectionToken) {\n        return url;\n      }\n      return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + \"id=\".concat(connectionToken);\n    }\n  }, {\n    key: \"_createTransport\",\n    value: function () {\n      var _createTransport2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n        var connectUrl, transportExceptions, transports, negotiate, _iterator, _step, endpoint, transportOrError, message;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\n              if (!this._isITransport(requestedTransport)) {\n                _context7.next = 8;\n                break;\n              }\n              this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n              this.transport = requestedTransport;\n              _context7.next = 6;\n              return this._startTransport(connectUrl, requestedTransferFormat);\n            case 6:\n              this.connectionId = negotiateResponse.connectionId;\n              return _context7.abrupt(\"return\");\n            case 8:\n              transportExceptions = [];\n              transports = negotiateResponse.availableTransports || [];\n              negotiate = negotiateResponse;\n              _iterator = _createForOfIteratorHelper(transports);\n              _context7.prev = 12;\n              _iterator.s();\n            case 14:\n              if ((_step = _iterator.n()).done) {\n                _context7.next = 53;\n                break;\n              }\n              endpoint = _step.value;\n              transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n              if (!(transportOrError instanceof Error)) {\n                _context7.next = 22;\n                break;\n              }\n              // Store the error and continue, we don't want to cause a re-negotiate in these cases\n              transportExceptions.push(\"\".concat(endpoint.transport, \" failed:\"));\n              transportExceptions.push(transportOrError);\n              _context7.next = 51;\n              break;\n            case 22:\n              if (!this._isITransport(transportOrError)) {\n                _context7.next = 51;\n                break;\n              }\n              this.transport = transportOrError;\n              if (negotiate) {\n                _context7.next = 35;\n                break;\n              }\n              _context7.prev = 25;\n              _context7.next = 28;\n              return this._getNegotiationResponse(url);\n            case 28:\n              negotiate = _context7.sent;\n              _context7.next = 34;\n              break;\n            case 31:\n              _context7.prev = 31;\n              _context7.t0 = _context7[\"catch\"](25);\n              return _context7.abrupt(\"return\", Promise.reject(_context7.t0));\n            case 34:\n              connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\n            case 35:\n              _context7.prev = 35;\n              _context7.next = 38;\n              return this._startTransport(connectUrl, requestedTransferFormat);\n            case 38:\n              this.connectionId = negotiate.connectionId;\n              return _context7.abrupt(\"return\");\n            case 42:\n              _context7.prev = 42;\n              _context7.t1 = _context7[\"catch\"](35);\n              this._logger.log(LogLevel.Error, \"Failed to start the transport '\".concat(endpoint.transport, \"': \").concat(_context7.t1));\n              negotiate = undefined;\n              transportExceptions.push(new FailedToStartTransportError(\"\".concat(endpoint.transport, \" failed: \").concat(_context7.t1), HttpTransportType[endpoint.transport]));\n              if (!(this._connectionState !== \"Connecting\" /* Connecting */)) {\n                _context7.next = 51;\n                break;\n              }\n              message = \"Failed to select transport before stop() was called.\";\n              this._logger.log(LogLevel.Debug, message);\n              return _context7.abrupt(\"return\", Promise.reject(new AbortError(message)));\n            case 51:\n              _context7.next = 14;\n              break;\n            case 53:\n              _context7.next = 58;\n              break;\n            case 55:\n              _context7.prev = 55;\n              _context7.t2 = _context7[\"catch\"](12);\n              _iterator.e(_context7.t2);\n            case 58:\n              _context7.prev = 58;\n              _iterator.f();\n              return _context7.finish(58);\n            case 61:\n              if (!(transportExceptions.length > 0)) {\n                _context7.next = 63;\n                break;\n              }\n              return _context7.abrupt(\"return\", Promise.reject(new AggregateErrors(\"Unable to connect to the server with any of the available transports. \".concat(transportExceptions.join(\" \")), transportExceptions)));\n            case 63:\n              return _context7.abrupt(\"return\", Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\")));\n            case 64:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee6, this, [[12, 55, 58, 61], [25, 31], [35, 42]]);\n      }));\n      function _createTransport(_x6, _x7, _x8, _x9) {\n        return _createTransport2.apply(this, arguments);\n      }\n      return _createTransport;\n    }()\n  }, {\n    key: \"_constructTransport\",\n    value: function _constructTransport(transport) {\n      switch (transport) {\n        case HttpTransportType.WebSockets:\n          if (!this._options.WebSocket) {\n            throw new Error(\"'WebSocket' is not supported in your environment.\");\n          }\n          return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\n        case HttpTransportType.ServerSentEvents:\n          if (!this._options.EventSource) {\n            throw new Error(\"'EventSource' is not supported in your environment.\");\n          }\n          return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\n        case HttpTransportType.LongPolling:\n          return new LongPollingTransport(this._httpClient, this._logger, this._options);\n        default:\n          throw new Error(\"Unknown transport: \".concat(transport, \".\"));\n      }\n    }\n  }, {\n    key: \"_startTransport\",\n    value: function _startTransport(url, transferFormat) {\n      var _this3 = this;\n      this.transport.onreceive = this.onreceive;\n      this.transport.onclose = function (e) {\n        return _this3._stopConnection(e);\n      };\n      return this.transport.connect(url, transferFormat);\n    }\n  }, {\n    key: \"_resolveTransportOrError\",\n    value: function _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat) {\n      var transport = HttpTransportType[endpoint.transport];\n      if (transport === null || transport === undefined) {\n        this._logger.log(LogLevel.Debug, \"Skipping transport '\".concat(endpoint.transport, \"' because it is not supported by this client.\"));\n        return new Error(\"Skipping transport '\".concat(endpoint.transport, \"' because it is not supported by this client.\"));\n      } else {\n        if (transportMatches(requestedTransport, transport)) {\n          var transferFormats = endpoint.transferFormats.map(function (s) {\n            return TransferFormat[s];\n          });\n          if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n            if (transport === HttpTransportType.WebSockets && !this._options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this._options.EventSource) {\n              this._logger.log(LogLevel.Debug, \"Skipping transport '\".concat(HttpTransportType[transport], \"' because it is not supported in your environment.'\"));\n              return new UnsupportedTransportError(\"'\".concat(HttpTransportType[transport], \"' is not supported in your environment.\"), transport);\n            } else {\n              this._logger.log(LogLevel.Debug, \"Selecting transport '\".concat(HttpTransportType[transport], \"'.\"));\n              try {\n                return this._constructTransport(transport);\n              } catch (ex) {\n                return ex;\n              }\n            }\n          } else {\n            this._logger.log(LogLevel.Debug, \"Skipping transport '\".concat(HttpTransportType[transport], \"' because it does not support the requested transfer format '\").concat(TransferFormat[requestedTransferFormat], \"'.\"));\n            return new Error(\"'\".concat(HttpTransportType[transport], \"' does not support \").concat(TransferFormat[requestedTransferFormat], \".\"));\n          }\n        } else {\n          this._logger.log(LogLevel.Debug, \"Skipping transport '\".concat(HttpTransportType[transport], \"' because it was disabled by the client.\"));\n          return new DisabledTransportError(\"'\".concat(HttpTransportType[transport], \"' is disabled by the client.\"), transport);\n        }\n      }\n    }\n  }, {\n    key: \"_isITransport\",\n    value: function _isITransport(transport) {\n      return transport && typeof transport === \"object\" && \"connect\" in transport;\n    }\n  }, {\n    key: \"_stopConnection\",\n    value: function _stopConnection(error) {\n      var _this4 = this;\n      this._logger.log(LogLevel.Debug, \"HttpConnection.stopConnection(\".concat(error, \") called while in state \").concat(this._connectionState, \".\"));\n      this.transport = undefined;\n      // If we have a stopError, it takes precedence over the error from the transport\n      error = this._stopError || error;\n      this._stopError = undefined;\n      if (this._connectionState === \"Disconnected\" /* Disconnected */) {\n        this._logger.log(LogLevel.Debug, \"Call to HttpConnection.stopConnection(\".concat(error, \") was ignored because the connection is already in the disconnected state.\"));\n        return;\n      }\n      if (this._connectionState === \"Connecting\" /* Connecting */) {\n        this._logger.log(LogLevel.Warning, \"Call to HttpConnection.stopConnection(\".concat(error, \") was ignored because the connection is still in the connecting state.\"));\n        throw new Error(\"HttpConnection.stopConnection(\".concat(error, \") was called while the connection is still in the connecting state.\"));\n      }\n      if (this._connectionState === \"Disconnecting\" /* Disconnecting */) {\n        // A call to stop() induced this call to stopConnection and needs to be completed.\n        // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n        this._stopPromiseResolver();\n      }\n      if (error) {\n        this._logger.log(LogLevel.Error, \"Connection disconnected with error '\".concat(error, \"'.\"));\n      } else {\n        this._logger.log(LogLevel.Information, \"Connection disconnected.\");\n      }\n      if (this._sendQueue) {\n        this._sendQueue.stop().catch(function (e) {\n          _this4._logger.log(LogLevel.Error, \"TransportSendQueue.stop() threw error '\".concat(e, \"'.\"));\n        });\n        this._sendQueue = undefined;\n      }\n      this.connectionId = undefined;\n      this._connectionState = \"Disconnected\" /* Disconnected */;\n      if (this._connectionStarted) {\n        this._connectionStarted = false;\n        try {\n          if (this.onclose) {\n            this.onclose(error);\n          }\n        } catch (e) {\n          this._logger.log(LogLevel.Error, \"HttpConnection.onclose(\".concat(error, \") threw error '\").concat(e, \"'.\"));\n        }\n      }\n    }\n  }, {\n    key: \"_resolveUrl\",\n    value: function _resolveUrl(url) {\n      // startsWith is not supported in IE\n      if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n        return url;\n      }\n      if (!Platform.isBrowser) {\n        throw new Error(\"Cannot resolve '\".concat(url, \"'.\"));\n      }\n      // Setting the url to the href propery of an anchor tag handles normalization\n      // for us. There are 3 main cases.\n      // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n      // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n      // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n      var aTag = window.document.createElement(\"a\");\n      aTag.href = url;\n      this._logger.log(LogLevel.Information, \"Normalizing '\".concat(url, \"' to '\").concat(aTag.href, \"'.\"));\n      return aTag.href;\n    }\n  }, {\n    key: \"_resolveNegotiateUrl\",\n    value: function _resolveNegotiateUrl(url) {\n      var index = url.indexOf(\"?\");\n      var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n      if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n        negotiateUrl += \"/\";\n      }\n      negotiateUrl += \"negotiate\";\n      negotiateUrl += index === -1 ? \"\" : url.substring(index);\n      if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n        negotiateUrl += index === -1 ? \"?\" : \"&\";\n        negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\n      }\n      return negotiateUrl;\n    }\n  }]);\n  return HttpConnection;\n}();\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\nexport var TransportSendQueue = /*#__PURE__*/function () {\n  function TransportSendQueue(_transport) {\n    _classCallCheck(this, TransportSendQueue);\n    this._transport = _transport;\n    this._buffer = [];\n    this._executing = true;\n    this._sendBufferedData = new PromiseSource();\n    this._transportResult = new PromiseSource();\n    this._sendLoopPromise = this._sendLoop();\n  }\n  _createClass(TransportSendQueue, [{\n    key: \"send\",\n    value: function send(data) {\n      this._bufferData(data);\n      if (!this._transportResult) {\n        this._transportResult = new PromiseSource();\n      }\n      return this._transportResult.promise;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._executing = false;\n      this._sendBufferedData.resolve();\n      return this._sendLoopPromise;\n    }\n  }, {\n    key: \"_bufferData\",\n    value: function _bufferData(data) {\n      if (this._buffer.length && typeof this._buffer[0] !== typeof data) {\n        throw new Error(\"Expected data to be of type \".concat(typeof this._buffer, \" but was of type \").concat(typeof data));\n      }\n      this._buffer.push(data);\n      this._sendBufferedData.resolve();\n    }\n  }, {\n    key: \"_sendLoop\",\n    value: function () {\n      var _sendLoop2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var transportResult, data;\n        return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!true) {\n                _context8.next = 22;\n                break;\n              }\n              _context8.next = 3;\n              return this._sendBufferedData.promise;\n            case 3:\n              if (this._executing) {\n                _context8.next = 6;\n                break;\n              }\n              if (this._transportResult) {\n                this._transportResult.reject(\"Connection stopped.\");\n              }\n              return _context8.abrupt(\"break\", 22);\n            case 6:\n              this._sendBufferedData = new PromiseSource();\n              transportResult = this._transportResult;\n              this._transportResult = undefined;\n              data = typeof this._buffer[0] === \"string\" ? this._buffer.join(\"\") : TransportSendQueue._concatBuffers(this._buffer);\n              this._buffer.length = 0;\n              _context8.prev = 11;\n              _context8.next = 14;\n              return this._transport.send(data);\n            case 14:\n              transportResult.resolve();\n              _context8.next = 20;\n              break;\n            case 17:\n              _context8.prev = 17;\n              _context8.t0 = _context8[\"catch\"](11);\n              transportResult.reject(_context8.t0);\n            case 20:\n              _context8.next = 0;\n              break;\n            case 22:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee7, this, [[11, 17]]);\n      }));\n      function _sendLoop() {\n        return _sendLoop2.apply(this, arguments);\n      }\n      return _sendLoop;\n    }()\n  }], [{\n    key: \"_concatBuffers\",\n    value: function _concatBuffers(arrayBuffers) {\n      var totalLength = arrayBuffers.map(function (b) {\n        return b.byteLength;\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n      var result = new Uint8Array(totalLength);\n      var offset = 0;\n      var _iterator2 = _createForOfIteratorHelper(arrayBuffers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          result.set(new Uint8Array(item), offset);\n          offset += item.byteLength;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return result.buffer;\n    }\n  }]);\n  return TransportSendQueue;\n}();\nvar PromiseSource = /*#__PURE__*/function () {\n  function PromiseSource() {\n    var _this5 = this;\n    _classCallCheck(this, PromiseSource);\n    this.promise = new Promise(function (resolve, reject) {\n      var _ref;\n      return _ref = [resolve, reject], _this5._resolver = _ref[0], _this5._rejecter = _ref[1], _ref;\n    });\n  }\n  _createClass(PromiseSource, [{\n    key: \"resolve\",\n    value: function resolve() {\n      this._resolver();\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(reason) {\n      this._rejecter(reason);\n    }\n  }]);\n  return PromiseSource;\n}();","map":{"version":3,"names":["AccessTokenHttpClient","DefaultHttpClient","AggregateErrors","DisabledTransportError","FailedToNegotiateWithServerError","FailedToStartTransportError","HttpError","UnsupportedTransportError","AbortError","LogLevel","HttpTransportType","TransferFormat","LongPollingTransport","ServerSentEventsTransport","Arg","createLogger","getUserAgentHeader","Platform","WebSocketTransport","MAX_REDIRECTS","HttpConnection","url","options","arguments","length","undefined","_classCallCheck","_stopPromiseResolver","features","_negotiateVersion","isRequired","_logger","logger","baseUrl","_resolveUrl","logMessageContent","withCredentials","Error","timeout","webSocketModule","eventSourceModule","isNode","require","requireFunc","__webpack_require__","__non_webpack_require__","WebSocket","EventSource","_httpClient","httpClient","accessTokenFactory","_connectionState","_connectionStarted","_options","onreceive","onclose","_createClass","key","value","_start","_asyncToGenerator","_regeneratorRuntime","mark","_callee","transferFormat","message","_message","wrap","_callee$","_context","prev","next","Binary","isIn","log","Debug","concat","abrupt","Promise","reject","_startInternalPromise","_startInternal","_stopPromise","stop","start","_x","apply","send","data","_sendQueue","TransportSendQueue","transport","_stop","_callee2","error","_this","_callee2$","_context2","resolve","_stopInternal","_x2","_stopInternal2","_callee3","_callee3$","_context3","_stopError","t0","t1","_stopConnection","_x3","_startInternal2","_callee4","_this2","negotiateResponse","redirects","_loop","_callee4$","_context5","_accessTokenFactory","skipNegotiation","WebSockets","_constructTransport","_startTransport","accessToken","_loop$","_context4","_getNegotiationResponse","sent","ProtocolVersion","_accessToken","delegateYield","_createTransport","inherentKeepAlive","_x4","_getNegotiationResponse2","_callee5","headers","_getUserAgentHeader","_getUserAgentHeader2","name","negotiateUrl","response","errorMessage","_callee5$","_context6","_slicedToArray","_resolveNegotiateUrl","post","content","_objectSpread","statusCode","JSON","parse","negotiateVersion","connectionToken","connectionId","_x5","_createConnectUrl","indexOf","_createTransport2","_callee6","requestedTransport","requestedTransferFormat","connectUrl","transportExceptions","transports","negotiate","_iterator","_step","endpoint","transportOrError","_callee6$","_context7","_isITransport","availableTransports","_createForOfIteratorHelper","s","n","done","_resolveTransportOrError","push","t2","e","f","finish","join","_x6","_x7","_x8","_x9","ServerSentEvents","LongPolling","_this3","connect","transportMatches","transferFormats","map","ex","_this4","Warning","Information","catch","lastIndexOf","isBrowser","aTag","window","document","createElement","href","index","substring","actualTransport","_transport","_buffer","_executing","_sendBufferedData","PromiseSource","_transportResult","_sendLoopPromise","_sendLoop","_bufferData","promise","_sendLoop2","_callee7","transportResult","_callee7$","_context8","_concatBuffers","arrayBuffers","totalLength","b","byteLength","reduce","a","result","Uint8Array","offset","_iterator2","_step2","item","set","err","buffer","_this5","_ref","_resolver","_rejecter","reason"],"sources":["/home/nico/expero/toolkit/signalR-test/client/node_modules/@microsoft/signalr/src/HttpConnection.ts"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: (keyof typeof TransferFormat)[];\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private _connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private readonly _httpClient: AccessTokenHttpClient;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    // Needs to not start with _ to be available for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private transport?: ITransport;\r\n    private _startInternalPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _stopPromiseResolver: (value?: PromiseLike<void>) => void = () => {};\r\n    private _stopError?: Error;\r\n    private _accessTokenFactory?: () => string | Promise<string>;\r\n    private _sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly _negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n\r\n        let webSocketModule: any = null;\r\n        let eventSourceModule: any = null;\r\n\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n\r\n        this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\r\n        this._connectionState = ConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this._connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Connecting;\r\n\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n\r\n            return Promise.reject(new AbortError(message));\r\n        } else if (this._connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n\r\n        this._connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this._connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Disconnecting;\r\n\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n\r\n    private async _stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n\r\n        try {\r\n            await this._startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n\r\n    private async _startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        this._httpClient._accessTokenFactory = this._accessTokenFactory;\r\n\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === ConnectionState.Disconnecting || this._connectionState === ConnectionState.Disconnected) {\r\n                        throw new AbortError(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\r\n                        this._httpClient._accessToken = accessToken;\r\n                        this._httpClient._accessTokenFactory = undefined;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this._connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers: {[k: string]: string} = {};\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n\r\n    private _createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async _createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            } else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n\r\n                    if (this._connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new AbortError(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private _constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent!, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private _startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this._stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private _resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    } else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this._constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private _stopConnection(error?: Error): void {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Connecting) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this._connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private _resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private _buffer: any[] = [];\r\n    private _sendBufferedData: PromiseSource;\r\n    private _executing: boolean = true;\r\n    private _transportResult?: PromiseSource;\r\n    private _sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly _transport: ITransport) {\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n\r\n    private _bufferData(data: string | ArrayBuffer): void {\r\n        if (this._buffer.length && typeof(this._buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this._buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n\r\n    private async _sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this._sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this._transportResult!;\r\n            this._transportResult = undefined;\r\n\r\n            const data = typeof(this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n\r\n            this._buffer.length = 0;\r\n\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private _resolver?: () => void;\r\n    private _rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this._resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this._rejecter!(reason);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}